Sire
====

-   TODO Move all logic from tests/*.sire into `sire/*.sire` modules.
    Replace test rountines with code that merely imports.

-   TODO Assertions should print evaluated arguments

    `?? eql (add 1 2) (inc 9)` should print `?? eql 3 10` to show what failed.

    Right now it just prints `1!=0` and `?? eql (add 1 2) (inc 9)`.

-   Carefully think through and document how inlining works.

    An `Inliner` is a function, whose local bindings are resolved (Refr),
    but will need to be re-keyed during inlining.  Whose global bindings
    are resolved directly to plunder values.

    And Inliner is a fully parsed and name-resolved expression, all
    macros have been expanded.

    However, no transformations have been performed.  No lambdas have
    been lifted.  No LETs have been removed.

    In particular, "inline application" and "static application" nodes
    are still in place.  Inlining can expose opportunities for further
    inlining (and static application) there were not possible before
    inlining.

    Somehow, on import, we want to export a table of "Globals".

-   TODO Compile-Time Application ({!! 0 0 3 0} 3 4)

    Go through each sub-expression and turn it into a Pln, then combine
    the results into a single (embeded value) Pln.  If we run into a
    local-reference, abort.

    -   SECOND PHASE:

        Whenever we bind a new local variable, check if it depends on
        any function arguments.  If it does not, then track it's Pln value
        (lazy so that we do no work unless we use it).

-   TODO: Optimize lets AGAIN after inlining

    Inlining can remove references to let-bindings, and we don't want
    to generate code for let-bindings that are not used.

-   TODO All command runes should be two-characters (except =)

    Use `/=`, `*=`, etc.  Having overlapping runes between commands and
    expressions is very confusing because commands are a superset of
    expressions (raw expressions interpreted as PRINT).

    -   TODO Give `XDUMPY` a two-char rune.
    -   TODO Give `XALIAS`, `/` a two-char rune.

-   TODO Cleanup SireExe.

Loot
====

- TODO Add QuickCheck tests for Loot (Val -> Text -> Val).

- Go futher and have every generated binder name in an output block get
  a unique name:

    For example, in the following code, we bind `j k l` many times:

        = (jam a b)
        @ c
           ? (jamCore d)
           @ e ((j k l & j (R3:0 k l)) jamCore)
           @ f ((j k l m n & j (R5:2 k l m n)) jamCore)
           @ g ((j k l m & j (R4:3 k l m)) jamCore)

    Large dis-assembled functions are noisy enough without the re-use of
    variables names.

    Instead, we should have:

        = (jam a b)
        @ c
           ? (jamCore d)
           @ e (h i j & h (R3:0 i j))-jamCore
           @ f (k l m n o & k (R5:2 l m n o))-jamCore
           @ g (p q r s & p (R4:3 q r s))-jamCore


Rex
===

-   The Open-mode printer should first walk continuation-sequence and
    produce a list.  This way, it doesn't need to worry about the
    does-it-have-an-heir case during the printing/indentation loop.

-   Figure out how to have an input prompt.

    It needs to support multiple lines.  It should probably change once
    a non-block-terminating non-space lines has been input.

-   Consider banning whitespace at the end of lines.

    -   For the REPL, the block parser can have an option to do stripEnd
        before lexing before lexing.

-   Embeded values branch of ADT should not have heir slot.

       What does it even mean to add a heir to an embed value?

       What if the embeded value is "rendered", and *that* has a heir?

-   Rex runes should be indentation sensitive along the right side (not left)

    These, for example, are aligned:

        %%% x
          | y
         ^^ z

    Instead of the current:

        %%% x
        | y
        ^^ z

    TODO: Then how would bare words need to be aligned?

        %%% x
          | y
         ^^ z
          hello

        Tempting to say that you just shouldn't do this.  (You shouldn't).

        However, the data structure does allow `(&& x)hello` and the tall
        form of that needs to be printable somehow.

            && x
             hello

    TODO What about pages?

        Maybe you know, like...

              | x
            """ Do you mean like this?

        Yes, I think it should work like that.

    TODO Does that imply that the space after ''' should be mandatory?

        No.  It looks weird, but it's okay.

                | x
              """y

-   TODO: should name-pages juxtaposition be accepted?

    This used to be supported, but it was removed when special syntax
    for namePage and nameCord were removed.

        X""" This is a
         """ Test.

    However, this is a perfectly coherent concept:

    - It might make the gramar more complex.

    - It breaks the usual assumption that the child of a wide-mode
      objects is in wide-mode.

        Or, to put that another way: `X""" x` can be printed only if it
        isn't in a nested construct.  It's a pretty specific edge-case.

    Overall, I think this syntax looks nice but may not be worth the
    complexity.

    If we were to use a rune instead.

    Actually, another data-point here is that:

        x&""" hi
        $"""x y z

    Are also pretty nice.  Should we allow pages in any non-nested
    context?

    This is actually not hard in the lexer, just accept pages anywhere.
    They will automatically fail to parse in any nested context.

    Main concern is that it's complicated to print correctly.


Plunder
=======

-   Jet mkPin, isPin, etc.

-   Lazy loading?

-   TODO Cabs are generic sets
-   TODO Tabs are generic maps

-   TODO Add a `Pad` datajet.

    Pads are bit-arrays just like Bars are byte-arrays.

    We should also use a jetted treeConcat operation that takes a
    rose-tree of Pads and concatenates all.  Build this for Bar as well.

        ??  eql  p#0012300  padFlat-[p#0 [p#0 p#12] p#3 p#00]

    TODO: Actually, I think pads should be handled the same was as
    w32, etc.  Pad operations take and return atoms.  They cast their
    inputs to pads.  Every atom is a valid pad except for `0`, if a pad
    operation is passed zero, it is treated as 1 (the empty pad).

-   TODO Bring back zero-arity rules.

    This makes the spec easier and resolves the need for hacks around
    x=(@ x y) syntax in Sire and Loot.  Instead, we will just always
    have bindings create functions.

-   TOOD Pin datajet.
-   TOOD Eliminate native pins.

-   In the Primop `1`, the nat branch should take the value as an
    argument.  This makes it practical to use directly, without lambdas
    around it.

Data Jets for Pins
------------------

I'm not ready to eliminate `4`, since that is going to be a lot of
work and it requires figuring out how to bootstrap the (f x)=x syntax.
However, I can build the pin data jet NOW.  Call it *Sin* and have it
be a new datatype.


Mandelbrot
==========

- TODO Get Mandelbrot code running correctly.


Bootstrapping
=============

Understand the event log implementation. If it isn't fully working
yet, see if I can help him with that.


Jar
---

-   TODO Jar does a state-monad traversal through the dependency tree,
    explicitly keeping track of which hashes are assigned to which pins.
    No more repeatedly processing the same pins.

Jam Optimiations:

- Rewrite `Jam` to produce a Pad.
- Rewrite `blake3` to produce a Bar (and to use a bar internally)
- Implement `cue` and `cap`.

- Heavy testing.

- Jet `jar`, `jam`, `cap`, and `cue`.  Heavily test these operations.

- Don't turn the external refs table into a list.

  To do a lookup, first scan the external referenses table, and then
  THEN the subtrees list.



Macro Interface
===============

-   TODO Use the following Rex representation:

    ```
    0-[t k s]   --  Leaf
    1-[r t k s] --  Node
    2-x         --  Embed
    ```

-   TODO Macros should return "new gensym state" instead of gensym
    increment.  It just simpler, don't need to be so defensive here.

-   `simpleMacro` and `gensymMacro` should be macros.

-   We should have a macro for less-common things that lets us use a
    macro-function by name.

    ```
    #  macroName
    body
    ```

    This also gives us a way to do data-type macros!

        x#ffxx
        x#"ffxx"
        b#turd
        b#"turd"
        p#0011

        # x """ ff00ff
            """ deadbeef

    Eliminating the open questions around x"asdf"

Macro System
============

-   Command parser should also do macro-expansion.

-   Make it so that macros can over-ride built-in syntax.

-   Make all built-in syntax have a short form `@` and a long form `#@`.
    This way, macro-expansions can target the stable two-character runes
    and be free to redefine the one-character version.

    In particular, we want to replace `*`, `@`, and `?` with versions
    that support pattern matching and destructuring.


Macros
======

-   `*` macro should support other forms of destructuring

    - Rows (already supported)
    - Tabs
    - Simple identifiers.
    - Composite patterns

    ```
    * [%[=k =v] x [y1 y2]] _ _
    ```

-   Pattern Matching (with destructuring)

    Something like this.  Whatever.

        ### x
          = 0            | %Zero
          = 9            | %Nine
          = @x (gte x 3) | mod x 3
          = %[=k]        | k
          = [x y]        | add x y
          = [x y z]      | add x add-y-z
          = (0 x)        | x
          = ~[a b c]     | x
          %fallback

-   Support fancy lambda syntax with LambdaCases and pattern matching.

Runner
======

Port runner over to the new Machine architecture (The runner has no
persistance).

Possible Naming Scheme for Hardware:

-   `0-65535`: Standard hardware (16 bits)
-   `65536-4294967296`: NonStandard Hardware (32 bits)
-   `4294967296-*`: Ephemeral Processes ("file descriptors")


Hardware Console
----------------

The Hardware Console lives at address=0

    data Request a where
        AcceptTerminalConnection :: Text -> Request Handle

Requests to the hardware console block until a new hardware terminal
is connected to the machine.  Then, the address of a new Socket is
returned, and that can be used to communicate between Plunder and the
hardware terminal.

The socket is essentially a telnet connection.

This provides a way for a Plunder processes to support remote-control
via a terminal interface.


Localhost HTTP Server
---------------------

The HTTP Server lives at Hardware=1

```
data Request a where
    HTTPServe  :: Map Text (Text, ByteString) -> Request a
    HTTPListen :: Text -> Request Handle
```

When the server gets a HTTPServe request, it makes the given data structure
available over HTTP.  The request never returns.  If the request is
canceled, the data is no longer served.  If multiple HTTPServe requests
happen simultaneously, both of them are accepted, but hardware will
arbitrarily choose which directory to serve.

When the server gets a HTTPListen request, it begins to accept websocket
requests at "/${key}".  When a websocket request comes in, a new hardware
address is created for that communication.  The new hardware is a simple
socket device with Read/Write requests that work with Bars.

This device is intended to allow Plunder code to build browser interfaces.


Persist
-------

Understand the event log implementation. If it isn't fully working
yet, see if I can help him with that.
