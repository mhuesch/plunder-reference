/+  boot
/+  io      [">>" forever]
/+  io      [getRandomBytes getCurrentTime waitUntil]
/+  io      [fork]
/+  io      [getThreadId getState]
/+  io      [newIORef readIORef writeIORef]
/+  io      [newMachine]
/+  switch  ["#switch"]


;; Demo ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; This will generate a random byte, get the current time,
;;; wait for $byte seconds, and repeat
;;;
;;; randomWait :: IORef Nat -> IO ()
= (randomWait vCount k)
: tid <- getThreadId
: bar <- getRandomBytes 1
: now <- getCurrentTime
@ off (mod (barIdx 0 bar) 5)
@ then (add now off)
: kd <- : cb <- fork
        : me <- getThreadId
        : _  <- waitUntil then
        | trk [%kid_waited_also then %[tid=me]]
        | cb 0
: x <- waitUntil then
: n <- readIORef vCount
: _ <- (@ x inc-n | seq x | writeIORef vCount x)
: s <- getState
| trk [%STATE s]
| trk [%waited_until then %[tid=tid child=kd count=n]]
| k x

= threadDemoTwice
| newMachine
& k
: v <- newIORef 0
; (randomWait v >> randomWait v) k
| (forever (randomWait v)) k


;; Manual Testing ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; threadDemoTwice %zod ;;; Boot Machine
; _ 1 x#11             ;;; Got a random byte.
; _ 1 234234234        ;;; Got the current time.
; _ 1 0                ;;; Finished waiting.
; _ 1 x#11             ;;; Got a random byte.
; _ 1 234234234        ;;; Got the current time.
; _ 1 0                ;;; Finished waiting.
; _ 2 0                ;;; First forked thread finishes waiting.
; _ 3 0                ;;; Second forked Thread finishes waiting.
; _ 1 x#11             ;;; Invalid response to trigger logging.


;; Export For Boot ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

<<threadDemoTwice
