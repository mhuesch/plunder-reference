/+  bool   (if not)
/+  nat    (lth)
/+  eql    (eql)
/+  row    (idx len drop)
/+  either (LEFT RIGHT)
/+  macro  (HEIR cnsE rexGetWord cordWeld)
/+  tab    (tabHas tabGet)

;;; TODO Handle cases where `x` is not a valid identifier (use one of
;;; these forms: ($"asdf" $234).
= (showSymbol x)
| x

= ("#" envr next kids heir)
@ rex
   (HEIR "#" kids heir)
| if (lth len-kids 1)
   LEFT-[rex "# Macros needs at least on kid"]
! rexGetWord (idx 0 kids)
   LEFT-[rex "First parameter to # must be a bare-word"]
& name
@ key (cordWeld "#" name)
| if (not tabHas-key-envr)
   LEFT-[rex (cordWeld "Undefined Symbol: " showSymbol-key)]
@ fun (tabGet envr key)
| fun envr next (drop 1 kids) heir
    ;;;
    ;;; TODO Really need to change the macro interface so that
    ;;; macros simple receive the whole rexpression they matched on.
    ;;;

= ("#foo" envr next kids heir)
| RIGHT [0 (cnsE %[=next =kids =heir])]

(foo#bar)zaz

?? eql (foo#bar)zaz
   %% =heir [1 %zaz]
   %% =kids [[1 %bar]]
   %% =next 0

;;;;;;;;;;;;;
;; Exports ;;
;;;;;;;;;;;;;

^-^ "#"
