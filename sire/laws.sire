/+  prim       (mkFun valCase natCase inc)
/+  prim       (isNat isApp isFun)
/+  prim       (funName funArgs funBody appHead appTail)
/+  prim       (car cdr)
/+  prim       (caar cadr cdar cddr)
/+  prim       (caaar caadr cadar caddr cdaar cdadr cddar cdddr)
/+  prim       (force seq deepseq trk trkVal die)

/+  combo      (S K I apply supply compose)

/+  bool       (T F Y N)
/+  bool       (toBool not if ifNot)
/+  bool       (and or xor nand nor xnor)

/+  nat        (inc dec add sub mod mul div)
/+  nat        (toNat aeqZero)
/+  nat        (aeq lth gth lte gte min max)
/+  nat        (even odd)
/+  nat        (roundUp blockWeld bitWidth takeByte dropByte)
/+  nat        (lsh rsh con mix dis bex)
/+  nat        (takeBits)

/+  eql        (eql neq)

/+  pin        (mkPin isPin pinItem)

/+  maybe      (NONE SOME maybeCase fromSome)

/+  either     (LEFT RIGHT eitherCase eitherOpen fromRight)
/+  either     (eitherOpenLeft eitherCaseLeft fromLeft)

/+  apply      (arity head idx get len)

/+  list_core  (NIL CONS listCase listMap listTurn)
/+  list_core  (listHead listSafeHead listUnsafeHead)

/+  row        (mkRow isCow isRow)
/+  row        (splice chunks replicate weld)
/+  row        (switch match)
/+  row        (gen foldr foldl)
/+  row        (update)
/+  row        (find has)
/+  row        (rowAnd rowOr sum all any zip zipWith)
/+  row        (concat concatMap)
/+  row        (map turn put take drop reverse)
/+  row        (rowApply)

/+  list       (listFoldl listFoldr listMap listTurn listLen)
/+  list       (listSum listToRow listToRowReversed listFromRow listAnd)
/+  list       (listOr listSum listAll listAny listHas listEnumFrom)
/+  list       (listWeld listConcat listTake listDrop listDigits digits)
/+  list       (listZipWith listZip listFilter listNull listMinimumOn)
/+  list       (listSortOn sortOn)

/+  tab        (tabLen tabIdx look tabKeys tabHas tabGet tabValues)
/+  tab        (tabSwitch tabMatch tabFromRow tabToRow tabToList tabPut)

/+  macro      (simpleMacro gensymMacro)
/+  macro      (eitherMap eitherRowSequence eitherRowTraverse cordWeld)
/+  macro      (cordConcat showNat EROR NODE HEIR WORD TEXT PAGE VRAW)
/+  macro      (mkHeir rexCase rexGetNode rexGetWord rexGetText natE varE)
/+  macro      (cnsE appE appE2 vecE letE txtE gensymE mergeHeir)
/+  macro      (rexGetNodeFolded tabE)

/+  pad        ("#p")
/+  pad        (toPad padNat padWeld natPad padFromBinary)

/+  bar        ("#b" "#x")
/+  bar        (byteWidth barTrail barEnc barDec mkBar natBar barNat)
/+  bar        (barPad barLen barIdx zEnd stripZEnd w8 bytesBar barGen)
/+  bar        (barGet barBytes barFoldl barFoldr barWeld barConcat)
/+  bar        (barIntercalate)

/+  w32        (w32 wMax32 wMin32)
/+  w32        (inc32 dec32 add32 mul32 div32)
/+  w32        (lth32 gth32 lte32 gte32 eql32)
/+  w32        (not32 and32 or32 xor32 lsh32 rsh32)
/+  w32        (chop32 isZero32 sub32 ror32 rol32)
/+  w32        (bitFlip32)

/+  w32        (i32 iMax32 iMin32)
/+  w32        (iIsZero32 iIsNeg32 iNeg32 iAbs32)
/+  w32        (iGth32 iLth32 iGte32 iLte32 iEql32)
/+  w32        (iInc32 iDec32 iAdd32 iSub32)
/+  w32        (iMul32 iDiv32)

/+  w48        (w48 wMax48 wMin48)
/+  w48        (inc48 dec48 add48 mul48 div48)
/+  w48        (lth48 gth48 lte48 gte48 eql48)
/+  w48        (not48)
/+  w48        (isZero48 sub48)
/+  w48        (bitFlip48)

/+  w48        (i48 iMax48 iMin48)
/+  w48        (iIsZero48 iIsNeg48 iNeg48 iAbs48)
/+  w48        (iGth48 iLth48 iGte48 iLte48 iEql48)
/+  w48        (iInc48 iDec48 iAdd48 iSub48)
/+  w48        (iMul48 iDiv48)

/+  openRow    ("#openRow" "openRowE")
/+  openRow    ("readSymbol" "okaySymbol")
/+  openTab    ("#openTab" "isOpenTabExp" "openTabE" "readOpenTabExp")
/+  hax        ("#")
/+  tic        ("`")
/+  tar        ("*")

/+  blake3     (blake3)

/+  cord       (explode implode)
/+  cord       (isDigit isUpper isLower isAlpha)

(gulf f t)=(gen (sub inc-t f) add-f)

= (mkInput y)
| map (x & mod x 256)
| gulf 0 dec-y

hexAlphabet=(natBar "0123456789abcdef")

(hexChar n)=(barGet hexAlphabet n)

= (hexByte n)
| implode
| map hexChar
,, takeBits 4 (rsh n 4)
,, takeBits 4 n

(showByte n)=(blockWeld 16 "0x" hexByte-n)

(rap w v)=(foldl (blockWeld w) 0 v)

= (showHash v)
| cordWeld "0x"
| rap 16
| map hexByte v

= (hexCharToNat v)
| if (lte v %9) (sub v %0)
| add 10 (sub (min v %f) %a)

= (barFromHex nat)
@ dig | map hexCharToNat explode-nat
@ pad | if (even len-dig) [] [0]
@ buf | listFromRow concat-[pad dig [0 1]]
. 0 buf 1
? (loop acc lis pos)
| seq acc
! listCase lis (0 1 1 acc)
& (a as)
! listCase as (die %impossible)
& (b bs)
@ acc {add acc | add mul-pos-b | mul-pos | mul 16 a}
| loop acc bs (mul 256 pos)

?? eql (add 1  0     ) | funBody | barFromHex '''
?? eql (add 1  bex-8 ) | funBody | barFromHex '''1
?? eql (add 16 bex-8 ) | funBody | barFromHex '''10
?? eql (add 1  bex-16) | funBody | barFromHex '''100
?? eql (add 16 bex-16) | funBody | barFromHex '''1000
?? eql 0xfe            | barNat  | barFromHex '''fe
?? eql 0xfe00          | barNat  | barFromHex '''00fe
?? eql 0xfe00          | barNat  | barFromHex '''00fe
?? eql 0xfe0011        | barNat  | barFromHex '''1100fe

?? eql | barConcat
       ,, x#7470ea5654831e01ffc04ee0e43a32fb
       ,, x#90227162dc0faaa14f9627d8f5c718f7
   {bytesBar | blake3 | explode "fdsafdsa"}

; All pins referenced by a val.
= (refs top)
| listToRowReversed
@ ini (if isPin-top pinItem-top top)
. NIL ini
? (go set non)
| if isPin-non
   | if (listHas non set) set
   | CONS non set
| if isApp-non
   @ set go-set-(car non)
   @ set go-set-(cdr non)
   | set
| if isFun-non
   | go-set-(funBody non)
| set

; Lookup into a map encoded as a list
; of [k v] pairs.
= (listLookup key l)
! listCase l NONE
& (x xs)
* [k v] x
| if (eql k key) (SOME v)
| listLookup key xs

= (dropHighBit x)
| sub x
| bex | dec bitWidth-x

= (mat nat)
| ifNot nat [1 1]
@ aSz bitWidth-nat
@ sSz bitWidth-aSz
@ bod | dropHighBit
      | mix (takeBits dec-sSz aSz) (lsh nat dec-sSz)
,, add aSz dec-(add sSz sSz)
,, | add (bex sSz)
   | lsh bod (inc sSz)

?? all (x & eql (mat idx-0-x) idx-1-x)
   ,, (0, [1 1])
   ,, (1, [2 2])
   ,, (2, [5 4])
   ,, (3, [5 20])
   ,, (4, [6 12])
   ,, (5, [6 28])
   ,, (6, [6 44])
   ,, (7, [6 60])
   ,, (8, [9 8])
   ,, (9, [9 72])


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some Monadic Operations on `Option` ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; sequence :: Row (Option a) -> Option (Row a)
= (optionRowSequence results)
. NIL listFromRow-results
? (loop acc rest)
! listCase rest
   SOME!(listToRowReversed acc)
& (mX more)
! maybeCase mX NONE
& x (loop (CONS x acc) more)

(optionRowTraverse f xs)=(optionRowSequence map-f-xs)

?? | eql NONE
   | optionRowSequence [SOME-3 SOME-4 NONE]

?? | eql SOME-[3 4 5]
   | optionRowSequence [SOME-3 SOME-4 SOME-5]


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: Monadic Bind on Macro Result ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= ("#@" env nex xs mK)
@ args (mergeHeir xs mK)
| if (neq 3 len-args) "Expected 3 parameters"
* [var exp bod] args
@ guardedBod
   | appE
   ,, cnsE if
   ,, appE [[4 isNat] var]
   ,, var
   ,, bod
| RIGHT
, 0
| NODE "@" [var exp guardedBod]

?? | eql %foo
   @ xxx %foo
   | if isNat-xxx xxx
   %bar

?? | eql %foo
   #@ xxx %foo
   %bar


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parsing Nat Literals ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

; (Char > Some Nat)
= (readDigit char)
| tabSwitch char NONE
%% ="0" SOME 0
%% ="1" SOME 1
%% ="2" SOME 2
%% ="3" SOME 3
%% ="4" SOME 4
%% ="5" SOME 5
%% ="6" SOME 6
%% ="7" SOME 7
%% ="8" SOME 8
%% ="9" SOME 9

; (Nat > Maybe Nat)
= (readNat n)
@ mDigits (optionRowTraverse readDigit explode-n)
! maybeCase mDigits NONE
& nums
@ f
   & (elem rest)
   * [pos acc] rest
   (mul 10 pos, add acc mul-pos-elem)
| ifNot len-nums NONE
! SOME (idx 1)(foldr f [1 0] nums)

?? eql SOME-1   readNat-"1"
?? eql SOME-12  readNat-"12"
?? eql SOME-123 readNat-"123"
?? eql NONE     readNat-""
?? eql NONE     readNat-"a"


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: Atomic Switch ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

= (readNatEither rex msg nat)
! maybeCase (readNat nat) LEFT-[rex msg] RIGHT

= (readNatWord rex)
@ msg """Not an atom literal (readNatWord)
! rexGetWord rex LEFT-[rex msg]
& word
! readNatEither rex msg word

= (readAtomLit rex)
@ bad (LEFT [rex "Not an atom literal (readAtomLit)"])
! rexCase rex
      & (rune kids heir)
      | if  | rowOr
            ,, neq "%" rune
            ,, neq 0   heir
            ,, neq 1   len-kids
          bad
      ! rexGetWord idx-0-kids bad
      | (num & RIGHT num)
  (x & {! readNatEither rex bad x})
  (x & RIGHT-x)
  (x & RIGHT-x)
  (v & if isNat-v RIGHT-v bad)

; readSwitchPattern
;     :: Rex
;     -> Rex
;     -> Either [Rex Text] [Maybe-Nat Rex]
= (readSwitchPattern pat)
| if  | and (eql 1   idx-0-pat)
            (eql "_" idx-1-pat)
   | RIGHT NONE
! eitherOpen (readAtomLit pat)
& x (RIGHT SOME-x)

; derpSwtichPattern :: Rex -> Rex -> Either Rex,Text [Maybe-Nat Rex])
= (derpSwitchPattern pat exp)
! eitherOpen (readSwitchPattern pat)
& nat
| RIGHT-(nat, exp)

= (unrollSlip2 rune fb rex)
. NIL rex
? (loop acc form)
@ fallback
    ! eitherCase fb-form I
    | (right & loop CONS-right-acc 0)
| if eql-0-form listToRowReversed-acc
! rexGetNode form fallback
& (n kids heir)
| if (neq rune n) fallback
| loop CONS-kids-acc heir

;
; unrollSlip2Tis
;     :: (Rex -> Either Rex,Text Rex,Rex)
;     -> Rex
;     -> Either Rex,Text (Row Rex,Rex)
;
= (unrollSlip2Tis fb rex)
. NIL rex
? (loop acc form)
@ fallback
   ! eitherOpen (fb form)
   & term
   | loop CONS-term-acc 0
| if (eql 0 form)
   | RIGHT listToRowReversed-acc
! rexGetNode form fallback
& (n kids heir)
| if (neq "=" n) fallback
@ nkid len-kids
| if (and (eql 1 nkid) (neq 0 heir))
   @ kid idx-0-kids
   | loop CONS-[kid heir]-acc 0
| if (neq 2 nkid)
   | LEFT [form "= node expects two parameters"]
| loop CONS-kids-acc heir

= (readSwitchPatterns rex)
@ fb (form & RIGHT [(WORD "_") form])
! eitherOpen (unrollSlip2Tis fb rex)
& clauses
! eitherOpen (eitherRowTraverse (rowApply derpSwitchPattern) clauses)
& cases
| RIGHT
. [cnsE-0 %[]] cases
| foldl
& (acc patExp)
* pat,exp   patExp
* _,caseTab acc
! maybeCase pat
   (put acc 0 exp)
   (k & put acc 1 (tabPut caseTab k exp))

; TODO should `simpleMacro` build the Pin + wrapper fun itself?
= ("#switch" env nex xs mK)
. env nex xs mK
| simpleMacro "#switch" [RIGHT readSwitchPatterns]
& (expr patterns)
; trkVal %LusPamResult
* fb,ps patterns
@ canUseRowIndex
   | listAnd
   | listZipWith eql listEnumFrom-0
   | listFromRow tabKeys-ps
@ rowImpl | appE [cnsE-switch    expr fb vecE-(tabValues ps)]
@ tabImpl | appE [cnsE-tabSwitch expr fb tabE-ps]
| RIGHT
| if canUseRowIndex rowImpl tabImpl

= (switchTest x)
# switch x
= 346    b#346
= 345    b#345
= %hi    b#hi
= "yop"  b#yop
| b#hur

?? eql b#346 switchTest-346
?? eql b#345 switchTest-345
?? eql b#hi  switchTest-(%hi)
?? eql b#yop switchTest-"yop"
?? eql b#hur switchTest-45

= (switchTest2 x)
# switch x
= _ %Other
= 0 %Zero
= 1 %One
= 2 %Two
= 3
| barNat b#Three

?? eql %Three switchTest2-3
?? eql %Two   switchTest2-2
?? eql %Other switchTest2-9

= (switchTest3 x)
# switch x
= 0 %Zero
= 1 %One
= 2 %Two
%Fallback


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Printing Rex Expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (valRex expr)
| TEXT "EMBED VAL"

= (showRex expr)
! rexCase expr
      & (r x k)
      @ hed | barConcat
            ,, b#"("
            ,, | barIntercalate b#" "
               | if (eql r '|') map-showRex-x
               | weld [natBar-r] map-showRex-x
            ,, b#")"
      | if (eql k 0) hed
      | barWeld hed showRex-k
   (name & natBar name)
   (cord & barConcat [b#'"' natBar-cord b#'"'])
   (page & showRex (TEXT cordConcat-page))
   (cnst & showRex valRex-cnst)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Scratch Pad: Pronouncing Numbers ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (natWords n)
# switch n
= 0 %Zero
. n
? (loop n)
# switch n
= 0 ""
= 1 %One
= 2 %Two
= 3 %Three
= 4 %Four
= 5 %Five
= 6 %Six
= 7 %Seven
= 8 %Eight
= 9 %Nine
| cordConcat
,, loop (div n 10)
,, natWords (mod n 10)

?? eql %ThreeFourFive natWords-345
?? eql %Zero          natWords-0
?? eql %OneZero       natWords-10


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Scratch Pad: Testing Rex Printing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?? eql b#'()'    (showRex `())
?? eql b#3       (showRex `3)
?? eql b#'"3"'   (showRex `"3")

= showRexExample
| mkPin
| showRex
`  = (showRex expr)
   ! rexCase expr
         & (r x k)
         @ hed | barConcat
               ,, b#"("
               ,, | barIntercalate b#" "
                  | if (eql r '|') map-showRex-x
                  | weld [natBar-r] map-showRex-x
               ,, b#")"
         | if (eql k 0) hed
         | barWeld hed showRex-k
      (name & natBar name)
      (cord & barConcat [b#'"' natBar-cord b#'"'])
      (page & showRex (TEXT cordConcat-page))
      (cnst & showRex valRex-cnst)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: Equality Operator ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= ("==" env nex params maybeCont)
@ args mergeHeir-params-maybeCont
| RIGHT
# switch len-args
= 0 (0, natE 1)
= 1 (0, appE (cnsE seq, idx 0 args, natE 1))
= 2 (0, appE (cnsE eql, idx 0 args, idx 1 args))
, 1
| @ tmp gensymE-nex
  | letE tmp idx-0-args
  . (listFromRow drop-1-args)
  ? (loop more)
  ! listCase more (die "impossible")
  & (x xs)
  ! listCase xs appE-[cnsE-eql tmp x]
  & (y ys)
  | appE
  ,, cnsE-and
  ,, appE [cnsE-eql tmp x]
  ,, loop xs

??(eql == eql == eql)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: Not-Equals Operator ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= ("/=" env nex xs mK)
. env nex xs mK
| simpleMacro "/=" [RIGHT RIGHT]
& (x y)
| RIGHT
| appE [cnsE-not (NODE "==" [x y])]

??(eql /= neq)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: Global Namespace as Value ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

("#getenv" env nex xs mK)=(RIGHT 0,(cnsE env))

?? eql $"#getenv" (tabGet #getenv "#getenv")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: Mutually Recursive Funs ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

= (readSignature rex)
@ mustBe """Function Signature must be a symbol `x` or signature `(x y z)`
@ err LEFT-[rex mustBe]
! rexCase rex
         & (rune args cont)
         @ noCont """name-sequence cannot have a continuation
         | if (neq rune "|") | err
         | if (neq cont 0)   | LEFT [rex noCont]
         | eitherRowTraverse readSymbol args
      & _
      ! eitherOpen (readSymbol rex)
         (res & [(idx 0 res)])
   (_ & err)
   (_ & err)
   (_ & err)

= (readCorePattern sig body)
! eitherOpen (readSignature sig)
   (args & RIGHT-[args body])

= (readCoreBody rex)
! eitherOpen
   | unrollSlip2Tis (rx & LEFT [rx 'Not a core arm']) rex
& clauses
| eitherRowTraverse (rowApply readCorePattern) clauses

= (anonLamE args body)
| HEIR "&" [appE-args] body

= (taggedLamE idn tag args body)
@ tagIdn (NODE "$" [idn natE-tag])
| HEIR "?" [appE-(weld [tagIdn] args)]
| body

?? | eql ` {? (a$3 x y)}z
   | taggedLamE `a 3 [`x `y] `z

= (matchE x f ps)
| appE [cnsE-match x f vecE-ps]

;;; TODO Need to fix macro interface because passing "#mutrec" to
;;; `gensymMacro` is nonsense.
= ("#mutrec" env nex kids heir)
. env nex kids heir
| gensymMacro "#mutrec"
   ,, readAtomLit
   ,, RIGHT
   ,, readCoreBody
& (nex coreTag letBody sigExpPairs)
@ coreIdn (gensymE nex)
@ coreArg (gensymE inc-nex)
@ bindArms
   ? (bindArms body arms)
   ! listCase arms body
   & (item rest)
   * key,arm item
   * sig,_ arm
   @ armArgs (map WORD drop-1-sig)
   | letE (WORD idx-0-sig)
       | anonLamE armArgs
       | appE
       ,, coreIdn
       ,, vecE-(weld [natE-key] armArgs)
   | bindArms body rest
@ arms
   | listZip listEnumFrom-0 listFromRow-sigExpPairs
@ branches
   | turn listToRow-arms
   & item
   * _,arm item
   * sig,body arm
   | NODE "*"
   @ binds | map WORD
           | weld ["_"] drop-1-sig
   ,, NODE "," binds
   ,, coreArg
   ,, body
@ coreBody (matchE coreArg natE-0 branches)
| RIGHT
, 2
| letE coreIdn
   | taggedLamE coreIdn coreTag [coreArg]
   | bindArms coreBody arms
| bindArms letBody arms

= (looper start)
# mutrec %loop
   {! loop start}
= (loop xx)
   | ifNot xx 0
   ! loop 0

= loopFun
? (looper start)
. [0 start]
? (loop b)
| match b 0
,, ifNot idx-1-b 0 loop-[0 0]

?? eql (car looper) (0 0 1)
?? eql (cdr looper) (0 (2 loopFun) 1)
?? eql looper       (mkPin loopFun)

= evenOdd
# mutrec %even_odd
   ,, mkPin | 0 %even 1 (0 even 1)
   ,, mkPin | 0 %odd  1 (0 odd 1)
= (even x)
   | ifNot x T {! odd dec-x}
= (odd x)
   | ifNot x F {! even dec-x}

even=(idx 0 evenOdd)
odd=(idx 1 evenOdd)

?? even 0
?? even 2
?? even 20
?? odd 1
?? odd 3
?? odd 21

;;;;;;;;;;;;;;;;;;;
;; Serialization ;;
;;;;;;;;;;;;;;;;;;;

= (jam external top)
@ pos | len external
@ tab | listZip (listFromRow external) (listEnumFrom 0)
# mutrec %loop
   * [_ s b _] {! go pos tab top}
   | add b bex-s
= (nat p t atm)
   * [sz bits] (mat atm)
   | (p, add 2 sz, mix 3 (lsh bits 2), t)
= (backref p t ref)
   * [sz bits] (mat ref)
   | (p, add 2 sz, mix 1 (lsh bits 2), t)
= (cel p t hed tel)
   * [p hSz hBits t2] {! go (inc p) t hed}
   * [p tSz tBits t3] {! go (inc p) t2 tel}
   @ siz (add 1)(add hSz tSz)
   @ bit (mul 2)(add hBits (lsh tBits hSz))
   | (p, siz, bit, t3)
= (go p t noun)
   ! maybeCase (listLookup noun t)
       @ t (CONS [noun p] t)
       | if isNat-noun {! nat p t noun}
       | if isApp-noun {! cel p t car-noun cdr-noun}
       @ hed (mkFun funName-noun funArgs-noun)
       ! cel p t hed funBody-noun
   & ref
   | if  | and isNat-noun
         | lte bitWidth-noun bitWidth-ref
      ! nat p t noun
   ! backref p t ref

;;; = (for sta row fun)
;;; . sta (rowToList row)
;;; ? (go sta lis)
;;; ! listCase lis
;;;
;;; = (jarSt tab val)
;;; @ depz | refs val
;;; @ pack | jam depz val
;;; @ byts | explode pack
;;; @ kids | for tab deps (s r & jarSt s pinItem-r)
;;; @ tab  | idx 0 kids
;;; @ head | map idx-0 (idx 1 kids)
;;; @ sepr | replicate 0 32
;;; @ cHed | concat head
;;; @ crip | concat (cHed, sepr, byts)
;;; @ hash | blake3 crip
;;; , tab [hash depz byts]
;;;
;;; = (jar2 val)
;;; | idx 1
;;; | jarSt NIL val

= (jar val)
@ depz | refs val
@ pack | jam depz val
@ byts | explode pack
@ head | map (r & idx 0 jar-(pinItem r)) depz
@ sepr | replicate 0 32
@ cHed | concat head
@ crip | concat (cHed, sepr, byts)
@ hash | blake3 crip
, hash depz byts

= (niceJar val)
* [hash deps byts] jar-val
%% =hash bytesBar hash
%% =deps deps
%% =bits bytesBar byts

(jarHash val)={bytesBar | idx 0 | jar val}
(jarBytz val)={bytesBar | idx 2 | jar val}
(pinHash val)=(if (not isPin-val) 0 jarHash-(pinItem val))
(pinBytz val)=(if (not isPin-val) 0 jarBytz-(pinItem val))

?? eql jarBytz-0       x#0f
?? eql jarBytz-1       x#1b
?? eql jarBytz-2       x#93
?? eql jarBytz-3       x#d3
?? eql jarBytz-(0 0)   x#fe
?? eql jarBytz-(2 0 3) x#4c3e0d
?? eql pinBytz-toNat   x#f8c043f7e614462f67f2e906

<<add
?? eql (pinHash add)
   x#bdac4dd0f4de34484c4dcf4534845a58545937fa28511977866ca8f2047ef5df

<<mul
?? eql (pinHash mul)
   x#b74e96e0385dcb18599b1570e3c5807a9284050258766cb7cd10b004713d2032

= (refsTable pin)
| tabFromRow
| turn refs-pin
& r ,, funName pinItem-r
    ,, pinHash r


;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: List Literals ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;

= (appify xs)
| if (eql 1 len-xs) idx-0-xs
| NODE "|" xs

= ("~" env nex xs mK)
@ err | LEFT
      ,, (HEIR "~" xs mK)
      ,, """~ expects to be wrapped around a tuple literal: `~[3 4 5]`
| if (or (neq 0 mK) (neq 1 len-xs)) err
! rexGetNode idx-0-xs err
& (rune kids heir)
| if (neq rune ",") err
| RIGHT
, 0
| foldr (x rex & vecE [x rex]) natE-0
| mergeHeir kids heir

= ("~~" env nex xs mK)
| RIGHT
, 0
| foldr (xs rex & vecE[appify-xs rex]) natE-0
| unrollSlip2 "~~" x&RIGHT[x]
| HEIR "~~" xs mK

?? eql ~[3 4 5] [3 [4 [5 0]]]
?? eql ~[3 4 5] ~~ 3
                ~~ 4
                ~~ 5


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Macro: Value Recursion (Knots) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; TODO This pattern can be macroified:
;;
;; ! eitherOpen expr
;; & var
;; | more
;;
;;   <==
;;
;; => var (eitherOpen expr)
;;  | more

;; ! rexGetNode more LEFT-[more "Knot binders must be a node"]
;; & (rune xs mK)
;; | ...
;;
;;   <==
;;
;; => (rune xs mK) [rexGetNode more LEFT-[more "Knot binders must be a node"]]
;;  | ...

= (readBindPairs rex)
! eitherOpen
   . NIL rex
   ? (loop acc more)
   ; trk [%loop %[=acc] %[=more]]
   | if eql-0-more (RIGHT acc)
   @ ded LEFT-[more "Knot binders must be an = node with 2 kids"]
   ! rexGetNode more ded
   & (rune xs mK)
   | if neq-"="-rune ded
   | if (neq 2 len-xs) ded
   * [lhs rhs] xs
   ! eitherOpen (readSymbol lhs)
   & sym
   | loop (CONS [cdr-sym rhs] acc) mK
& res
| RIGHT | listToRowReversed res

;;;
;;; TODO Broken macro.  Unit test the SHIT out of all of this macro code.
;;;
;;; = ("#knot" env nex xs mK)
;;; . env nex xs mK
;;; | gensymMacro "#knot" [readBindPairs RIGHT]
;;; & (nex bindPairs body)
;;; @ knotRef  | gensymE nex
;;; @ bindSymz | map idx-0 bindPairs
;;; @ bindVals | map idx-1 bindPairs
;;; | RIGHT
;;; , 1
;;; | letE knotRef
;;;    | opnE bindSymz knotRef vecE-bindVals
;;; | opnE bindSymz knotRef body
;;;
;;; ?? | listTake 3
;;;    # knot = x (CONS 3 y)
;;;           = y (CONS 4 x)
;;;    | x
;;;

;;;;;;;;;;;;;;;
;; Val Types ;;
;;;;;;;;;;;;;;;

= (unApp f args)
| if isApp-f
   | unApp car-f
   ! CONS cdr-f args
| listToRow
! CONS f args

= (inspect x)
| if isApp-x (unApp car-x | CONS cdr-x NIL)
| if isFun-x [mkFun funName-x funArgs-x funBody-x]
| x

= (fullInspection x)
@ res inspect-x
| if isNat-res res
| map fullInspection res

= (runVec exp)
@ hed idx-0-exp
@ tel drop-1-exp
| rowApply hed tel

= (rebuild spec)
| if isNat-spec spec
| runVec map-rebuild-spec

= (unCell f args)
| if isNat-f (listToRow CONS-f-args)
| unApp car-f (CONS cdr-f args)

= (showTreeBar x)
| if isNat-x
   | if okaySymbol-x (barWeld b#'%' natBar-x)
   | natBar showNat-x
@ node | unCell car-x (CONS cdr-x NIL)
@ kids | barIntercalate b#" " map-showTreeBar-node
| barConcat ( b#"(" , kids , b#")" )

(showTree x)=(barNat showTreeBar-x)

= (showTree2 x)
| if isNat-x x
| R2 (showTree2 car-x) (showTree2 cdr-x)


;;;;;;;;;;;;;;;;;;;;;;;;
;; Plunder in Plunder ;;
;;;;;;;;;;;;;;;;;;;;;;;;

;todo


;;;;;;;;;;;;;;;;;
;; Scratch Pad ;;
;;;;;;;;;;;;;;;;;

;#?(eql==eql==eql)
;
;#?(eql /= neq)
;
;#?{: (x=3)(y=4)(z=5) y}

#getenv
